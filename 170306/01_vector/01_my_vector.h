#ifndef MY_VECTOR_H_
#define MY_VECTOR_H_

#include <cstddef>
#include <memory>  // Для placement new.

template <class T>
class my_vector{
public:
    my_vector();

    // Примитивные типы принято передавать по значению.
    my_vector(size_t n);
    
    // Все остальные параметры - константные ссылки, если не требуется иное.
    // Иное может требоваться только если метод очевидно должен поменять
    // свой параметр (например, в `swap` или `friend operator>>`).
    my_vector(const my_vector& other);
    
    // Возвращаемое значение - либо по значению (чтобы не думать про владельца,
    // но тогда будут копирования), либо по ссылке, если мы хотим, чтобы
    // операторы можно было вызывать по цепочке. Например, `operator=`
    // возвращает `*this`:
    //     a = b = c = d;
    //     a = (b = (c = d));
    // Или так (`operator<<` возвращает ссылку на `ostream`):
    //     std::cout << a << b << c;
    //     ((std::cout << a) << b) << c;
    //
    // Кстати, copy swap trick для `operator=` можно использовать:
    // тогда сложнее налажать, потому что освобождением старых ресурсов
    // займётся деструктор, а копированием - конструктор копирования. А в
    // C++11, когда "правило трёх" сменится "правилом пяти", copy swap
    // вообще тащит.
    my_vector& operator=(const my_vector& other) {
      // Помните, что конструкция `v = v` может быть завуалирована как
      // `a[i] = a[j]`. То есть вероятно, что `this == &other`. Это просто
      // дурацкий крайний случай, обычно его разбирают отдельно.
      if (this == &other) {
        return *this;
      }
      // Пошёл нормальный код.
    }
    ~my_vector();

    // Если операция не меняет объект, то должен быть const-qualifier.
    // Как минимум, все геттеры наверняка будут const-qualified.
    size_t size() const;
    size_t capacity() const;
    bool empty() const;

    // А вот эти уже объект меняют, так что const-qualifier нет.
    void resize(size_t n);
    void reserve(size_t n);

    // Иногда надо сделать две версии: одна разрешает менять объект,
    // а другая - только на чтение. Обычно возникают возле `operator[]`
    // и ему подобных. Другая подсказка: если вы возвращаете ссылку или
    // указатель на что-то, то наверняка нужно две версии. Иначе получится,
    // что у константного объекта можно получить ссылку/указатель на
    // неконстантные данные и поменять. См. `bad_const.cpp`.
    T& operator[](size_t index);
    const T& operator[](size_t index) const;

    // Опять же - параметр всегда передаём по константной ссылке, если
    // только нет причин делать иначе.
    void push_back(const T& t) {
      // Вызов публичного интерфейса вместо перевыделений и `if`.
      // `reserve()` сам разберётся и округлит до степени двойки.
      reserve(size_ + 1);
      /*
      // А вот так - если бы не было требования про степень двойки
      // и мы бы хотели амортизировать `push_back`.
      if (size_ == capacity_) {
        reserve(2 * capacity_);
      }
      */

      // И две строчки, которые занимаются только синхронизацией
      // `size_` и объектов в `array_`.
      new (array_ + size_) T(t);
      size_++;
    }

    void pop_back();

    void clear() {
      // Реализация просто через публичный интерфейс, думать не надо.
      resize(0);
    }

private:
    size_t capacity_;
    size_t size_;
    T* array_;

    // 1. Если нужны вспомогательные методы - делаем приватными.
    // 2. Интерфейс должны быть легко использовать правильно и
    //    сложно - неправильно.
    // 3. Предполагайте, что публичный интерфейс могут вызывать вообще в
    //    произвольном порядке. Если вам важен порядок вызова функций, то
    //    скорее всего, они не должны быть в публичном интерфейсею
    // 4. При реализации функций (даже внутри класса) старайтесь использовать
    //    только публичный интерфейс. Напрямую менять члены или вызывать
    //    приватные функции, только если очень надо.
    // 5. Конкретно в векторе можно было бы выделить ещё один вспомогательный
    //    класс, который бы отвечал за синхронизацию `capacity_` и `array_`.
    //    А сам вектор бы отвечал за синхронизацию создания объектов в `array_`
    //    и `size_`. Сейчас код может быть сложный, потому что эти сущности
    //    управляются одновременно - что-то в `resize`, что-то в `reserve`.
    //    Явное разделение могло бы упростить жизнь, но традиционно вектор пишут
    //    одним классом.
    // 6. Хороший интерфейс - это важно и не всегда тривиально. Именно поэтому
    //    в задании на него отводились отдельные баллы. Иногда баг можно поймать,
    //    просто смотря на интерфейс (см. `04_bad_const.cpp`).
};
#endif